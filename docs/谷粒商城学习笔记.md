# TODO

stream流学习

旧：192.168.43.187

更换数据库

192.168.200.153   --- > 192.168.31.171

# 启动

启动nacos-1,启动gateway

启动renren-fast-vue

启动renrenApplication



进度：55

# mysql

安装

```shell
docker run -p 3306:3306 --name JY_mysql -e MYSQL_ROOT_PASSWORD=123456 -d mysql
 docker exec -it cf0e056371f9 /bin/bash  进入mysql交互
```

# redis

安装

```
docker run -p 6379:6379 --name redis -v /mydata/redis/data:/data -v /mydata/redis/conf/redis.conf:/etc/redis/redis.conf --privileged=true -d d4f259423416 redis-server /etc/redis/redis.conf

docker run -p 6379:6379 -d d4f259423416 redis-server

docker exec -it 22873cd482a3 redis-cli
sudo docker update redis --restart=always
```

# nacos

```shell
sh startup.sh -m standalone     # 启动nacos, 单机版

http://127.0.0.1:8848/nacos/
```

# Picgo

```shell
picgo upload  # 上传剪切板内容，上传后自动复制到剪切板
```

# vue

```shell
问题：Node Sass does not yet support your current environment: OS X 64-bit with Unsupported runtime
参考：https://blog.csdn.net/yaya07755/article/details/96834875
解决：
1.先卸载
npm uninstall --save node-sass

2.清除缓存
npm cache clean -f

3.升级node-sass模块
npm install --save node-sass


快捷键
httppost
httpget
```

# mybatis

## 逻辑删除

* 配置全局的逻辑删除规则
* 配置逻辑删除的组件Bean，高版本可省略
* 给Bean加上逻辑删除注解@TableLogic

# 数据校验

Jsr303



分组校验

```

@Validated({UpdateGroup.class})
```



# 一些报错

p100集规格报错

```sql
INSERT INTO sys_menu (menu_id, parent_id, name, url, perms, type, icon, order_num) VALUES (76, 37, '规格维护', 'product/attrupdate', '', 2, 'log', 0);
```

# ES

9200 9300

kibana是ES的可视化界面

http://192.168.31.171:5601/app/kibana#?_g=()



https://easydoc.xyz/s/78237135/ZUqEdvA4/Tpz10eVn





https://github.com/cosmoswong/gulimall

# 本机ip

 192.168.31.219

# 优化

## 动静分离

动态请求经过网关，静态不经过，直接放在nginx里面。

## redis

### 读模式

* 缓存穿透：查询一个null数据，解决：缓存空数据
* 缓存击穿：大量并发进来同时查询一个正好过期的数据，解决：加锁，分布式锁
* 缓存雪崩：大量的key同时过期，解决：加随机时间

### 写模式

* 读写加锁
* 引入canal，感知到mysql的更新去更新数据库
* 读多写多，直接去查数据库

总结：

常规数据(读多写少，即时性，一致性要求不高的数据)，完全可以使用spring-cache.





属性：

* CPU品牌
* CPU型号



创建线程的方式：

* 继承Thread
* 实现Runable接口
* 实现Callable接口+FutureTask
* 线程池



# 分布式Session

session存到redis中，整合springsession





## ES

迁移数据

```
POST _reindex
{
  "source": {
    "index": "product"
  },
  "dest": {
    "index": "gulimall_product"
  }
}
```

# 购物车

* 离线购物车
* 在线购物车

使用ThreadLocal共享数据，同一个用户请求，都用的同一个线程。



wardseptember/mynotes

GITEE_RSA_PRIVATE_KEY

# RabbitMQ

* 一个客户端只会建立一个长链接，长连接里面可以有很多channel
* 消息发布者是将消息发给exchange，exchange将消息分发给queue，channel对接上queue就可以接受消息了
* Broker里面可以有多个虚拟主机，各个虚拟主机之间互不影响。
* Exchange和queue之间靠binding连接着，binding决定交换机的消息应该发送到那个队列
* exchange也可以跟exchange绑定

```
docker run -d --name rabbitmq -p 5671:5671 -p 5672:5672 -p 4369:4369 -p 25672:25672 -p 15671:15671 -p 15672:15672 rabbitmq:management

docker update rabbitmq --restart=always
```

Exchange类型

* direct是直接点对点的交互接，

* fanout是广播交换机，无论路由键是什么，全部queue都能收到

* topic是主题交换机，可以匹配主题的

* header也是点对点，效率低，不使用

一些点

* @RabbitLister 可以标注在类和方法上，监听哪些队列即可
* @RabbitHandler： 标在方法上，重载区分不同消息

## 消息确认机制

保证消息可靠抵达

publisher到broker会确认

exchange到queue会确认

queue到consumer会确认

# Feign远程调用丢失请求头

feign进行远程调用会经过一系列拦截器，创建一个新的request，里面没有任何请求头，

解决：

加上Feign远程调用拦截器，

```java
@Configuration
public class GulimallFeignConfig {
    @Bean("requestInterceptor")
    public RequestInterceptor requestInterceptor() {
        return template -> {
            ServletRequestAttributes requestAttributes = (ServletRequestAttributes) RequestContextHolder.getRequestAttributes();
            if (!ObjectUtils.isEmpty(requestAttributes)) {
                HttpServletRequest request = requestAttributes.getRequest();// 老请求
                if (!ObjectUtils.isEmpty(request)) {
                    String cookie = request.getHeader("Cookie");
                    template.header("Cookie", cookie);
                }
            }
        };
    }
}
```

## Feign异步远程调用丢失请求头

```
        RequestAttributes requestAttributes = RequestContextHolder.getRequestAttributes();

        CompletableFuture<Void> getAddressedTask = CompletableFuture.runAsync(() -> {
            // 1 远程查询会员的所有列表
            RequestContextHolder.setRequestAttributes(requestAttributes);
            List<MemberAddressVO> addresses = memberFeignService.getAddresses(memberResponseVO.getId());
            orderConfirmVO.setAddresses(addresses);
        }, threadPoolExecutor);
```

# 订单

接口幂等性，防止订单重复提交

接口幂等性：用户发起一次请求和多次请求结果一致

幂等性解决：

* token机制

* 各种锁机制
* 各种唯一约束
* 防重表
* 全局唯一请求ID，防重令牌，存在页面和redis



难点：

1. 远程锁库存假异常，远程服务执行成功，由于网络故障等没返回，订单回滚，但库存减了

2. 远程服务执行成功，返回成功，以后代码出异常，无法回滚

分布式事务解决上面两个问题。

## 分布式事务

CAP

一致性(Consistency)、可用性(Availability)、分区容错性(Partition tolerance)

CA只能二选一

保持一致性，raft算法

### BASE理论

* 基本可用
* 软状态，
* 最终一致性

### 常见解决方案

1. 2PC模式，性能差
2. 柔性事务，写三份代码，try、confirm、cancel
3. 最大努力通知型方案
4. 可靠消息+最终一致性方案

### 谷粒商城采用方案

使用延时队列，实现最终一致性。

解锁库存：

* 下单成功，库存锁定成功，接下来的业务失败，需要解锁库存
* 下单成功，30min未付款

```
spring.application.name=gulimall-seckill
server.port=25000
spring.thymeleaf.cache=false

spring.session.store-type=redis

spring.redis.host=192.168.31.171
spring.cloud.nacos.discovery.server-addr=127.0.0.1:8848
spring.cloud.nacos.config.server-addr=127.0.0.1:8848
```

# 定时任务





# sentinel



# sleuth + zipkin





* 缓存
* 异步
* 队排好





# 重点

实现功能：

* 后台管理系统

* 登录注册、单点登录和社交登录
* 查询(ES)
* 离线购物车和在线购物车，结算
* 秒杀功能
* redis缓存商品分类数据

## 数据校验

后端JSR303校验

## redis

### 缓存击穿、穿透、雪崩

| 类型     | 描述                                                         | 解决                                                         |
| -------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 缓存击穿 | 对于一些设置了过期时间的 key，如果这些 key 可能会在某些时间点被超高并发地访问，是一种非常“热点”的数据。如果这个 key 在大量请求同时进来前正好失效，那么所有对这个 key 的数据査询都落到db. | 加锁。大量并发只让一个去查，其他人等待，査到以后释放锁，其他人获取到锁，先查缓存，就会有数据，不用去 db |
| 缓存穿透 | 指查询一个一定不存在的数据，由于缓存是不命中，将去查询数据库，但是数据库也无此记录，我们没有将这次查询的null写入缓存，这将导致这个不存在的数据每次请求都要到存储层去査询，失去了缓存的意义。利用不存在的数据进行攻击，数据库瞬时压力增大，最终导致崩溃 | nul 结果缓存，并加入短暂过期时间                             |
| 缓存雪崩 | 缓存雪崩是指在我们设置缓存时 key 采用了相同的过期时间，导致缓存在某一时刻同时失效，请求全部转发到 DB, DB 瞬时压力过重雪崩。 | 原有的失效时间基础上增加一个随机值，比如 1-5 分钟随机，这样每一个缓存的过期时间的重复率就会降低，就很难引发集体失效的事件。 |

