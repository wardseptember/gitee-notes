# 创建型模式

## 工厂方法



## 单例模式

### 饿汉式

类加载到内存后，就实例化一个单例，JVM保证线程安全。唯一缺点：不管用到与否，类装载时就完成实例化。

```java
package com.company;

/**
 * @author wardseptember
 * @create 2020-07-28 19:35
 */
public class Singleton01 {
    private static final Singleton01 INSTANCE = new Singleton01();
    private Singleton01() {
    };
    public static final Singleton01 getInstance() {
        return INSTANCE;
    }

    public static void main(String[] args) {
        Singleton01 singleton1 = Singleton01.getInstance();
        Singleton01 singleton2 = Singleton01.getInstance();
        System.out.println(singleton1 == singleton2);
    }
}
```

### 懒汉式——sync

```java
package com.company;

/**
 * @author wardseptember
 * @create 2020-07-28 19:53
 */
public class Singleton02 {
    private static Singleton02 INSTANCE;

    private Singleton02() {
    }

    public static synchronized Singleton02 getInstance() {
        if (INSTANCE == null) {
            try {
                Thread.sleep(1);
            } catch (InterruptedException e) {
                e.printStackTrace();
            }
            INSTANCE = new Singleton02();
        }
        return INSTANCE;
    }

    public static void main(String[] args) {
        for(int i=0; i<100; i++) {
            new Thread(()-> {
                System.out.println(Singleton02.getInstance().hashCode());
            }).start();
        }
    }
}
```

这种写法，不用在类加载时就实例化，而是需要时才实例化。synchronized加在方法上，效率受到影响。

### 懒汉式——sync优化

```java
package com.company;

/**
 * @author wardseptember
 * @create 2020-07-28 19:53
 */
public class Singleton03 {
    private static volatile Singleton03 INSTANCE;

    private Singleton03() {
    }

    public static synchronized Singleton03 getInstance() {
        if (INSTANCE == null) {
            synchronized (Singleton03.class) {
                if (INSTANCE == null) {
                    try {
                        Thread.sleep(1);
                    } catch (InterruptedException e) {
                        e.printStackTrace();
                    }
                    INSTANCE = new Singleton03();
                }
            }
        }
        return INSTANCE;
    }

    public static void main(String[] args) {
        for(int i=0; i<100; i++) {
            new Thread(()-> {
                System.out.println(Singleton03.getInstance().hashCode());
            }).start();
        }
    }
}
```

synchronized进一步细粒化，比上一种方式提高一点效率。

### 静态内部类方式

加载外部类时内部类不会加载，这样可以实现懒加载，而且线程安全。

```java
package com.company;

/**
 * @author wardseptember
 * @create 2020-07-28 19:53
 */
public class Singleton04 {
    private Singleton04() {
    }

    private static class SingletonHolder {
        private static final Singleton04 INSTANCE = new Singleton04();
    }

    public static Singleton04 getInstance() {
        return SingletonHolder.INSTANCE;
    }

    public static void main(String[] args) {
        for(int i=0; i<100; i++) {
            new Thread(()-> {
                System.out.println(Singleton04.getInstance().hashCode());
            }).start();
        }
    }
}
```

### 枚举类

不仅可以解决线程同步，还可以防止反序列化。

```java
package com.company.singleton;

/**
 * @author wardseptember
 * @create 2020-07-28 20:38
 */
public enum Singleton05 {
    INSTANCE;
    public static void main(String[] args) {
        for(int i=0; i<100; i++) {
            new Thread(()->{
                System.out.println(Singleton05.INSTANCE.hashCode());
            }).start();
        }
    }
}
```

## 策略模式

java Comparator是策略模式。